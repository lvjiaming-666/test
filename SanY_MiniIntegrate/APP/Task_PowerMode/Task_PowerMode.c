/*!Warning!:Please don't modify this file,this is generated by tools!*/
/********************************************************************
File name: Task_PowerMode.c
Author: Stephen Du
Version: V1.0
Timestamp: 2022-09-03 11:39:40
Description:
Others:
Function List:
1. ....
History: /
1. Date:
Author:
Modification:
2. ...
********************************************************************/
#include "Task_PowerMode_Cfg.h"

/*----------------------------- START: USER INCLUDED ----------------------------*/
/* OS Kernel includes */
#include "FreeRTOS.h"
#include "queue.h"
#include "PowerCtr.h"
#include "StateMachine.h"
#include "Temperature.h"
/*------------------------------ END: USER INCLUDE ------------------------------*/
extern QueueHandle_t QueueHandle_Timer50ms;
extern QueueHandle_t QueueHandle_Timer100ms;
/* Application related event*/
extern QueueHandle_t QueueHandle_Ign;
extern QueueHandle_t QueueHandle_VcuReq;
extern QueueHandle_t QueueHandle_AcReq;

void Task_PowerMode(void * pvParameters)
{
	static QueueSetHandle_t xQueueSet;
	static QueueSetMemberHandle_t xActivateMember;
	uint32 xReceivedFromQueue;

	/***************************** START: VARIABLE DEFINE ****************************/
	sint16 Temp_BattWaterIn = 0;
	/****************************** END: VARIABLE DEFINE *****************************/
	(void) pvParameters;

	/* Create the queue set large enough to hold an event for every space in every queue
	 * and semaphore that is to be added to the set. */
	xQueueSet = xQueueCreateSet(5);
	/* Add the queues or semaphores to the set. Reading from these queues can only be performed
	 * after a call to xQueueSelectFromSet() has returned the queue. You can't add too many elements.
	 * The number of elements is limited when creating a list. */
	xQueueAddToSet(QueueHandle_Timer50ms, xQueueSet);
	xQueueAddToSet(QueueHandle_Timer100ms, xQueueSet);
	xQueueAddToSet(QueueHandle_Ign, xQueueSet);
	xQueueAddToSet(QueueHandle_VcuReq, xQueueSet);
	xQueueAddToSet(QueueHandle_AcReq, xQueueSet);
	SM_Main(SM_SIG_SYS_ON);

	/********************* START: SOMETHING ONLY NEED EXEC ONCE **********************/

	/********************** END: SOMETHING ONLY NEED EXEC ONCE ***********************/
	for(;;)
	{
		/* Block to wait for something to be available from the queues that have been added to the set. */
		xActivateMember = xQueueSelectFromSet(xQueueSet, portMAX_DELAY);
		xQueueReceive(xActivateMember, &xReceivedFromQueue, 0);
		/* Which set member was selected? Receives/takes can use a block time of zero
		 * as they are guaranteed to pass because xQueueSelectFromSet() would not have returned
		 * the handle unless something has available. */
		if(xActivateMember == QueueHandle_Timer50ms)
		{
			SM_Main(SM_SIG_MAX);
		}
		else if(xActivateMember == QueueHandle_Timer100ms)
		{
			Temp_BattWaterIn = Temper_GetBattWaterIn();
			if(Temp_BattWaterIn < 250)
			{
				SM_Main(SM_SIG_TEMP_SMALL_THAN_25);
			}
			else if(Temp_BattWaterIn < 300)
			{
				SM_Main(SM_SIG_TEMP_SMALL_THAN_30);
			}
			else if(Temp_BattWaterIn > 300)
			{
				SM_Main(SM_SIG_TEMP_BIG_THAN_30);
			}
		}
		else if(xActivateMember == QueueHandle_Ign)
		{
			if( 0 == xReceivedFromQueue)
			{
				//SM_Main(SM_SIG_IGN_OFF); //TODO
			}
			else if( 1 == xReceivedFromQueue)
			{
				//SM_Main(SM_SIG_IGN_ON); //TODO
			}
		}
		else if(xActivateMember == QueueHandle_VcuReq)
		{
			if( 1 == xReceivedFromQueue)
			{
				//SM_Main(SM_SIG_VCU_COOL); //TODO
			}
			else if( 2 == xReceivedFromQueue)
			{
				//SM_Main(SM_SIG_VCU_WARM); //TODO
			}
		}
		else if(xActivateMember == QueueHandle_AcReq)
		{
			if( 0 == xReceivedFromQueue)
			{
				SM_Main(SM_SIG_AC_OFF);
			}
			else if( 1 == xReceivedFromQueue)
			{
				SM_Main(SM_SIG_AC_ON);
			}
		}
	}
}
/*=========================== END OF FILE: Task_PowerMode.c ===========================*/
